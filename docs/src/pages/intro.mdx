---
title: HarmonyLite - A Distributed SQLite Replication System
---

# What is HarmonyLite?

HarmonyLite is a distributed SQLite replication system with leaderless architecture and eventual consistency. Built on top of the fault-tolerant [NATS JetStream](https://nats.io/), it enables robust multi-directional replication between database nodes without requiring a primary server.

## Why HarmonyLite?

SQLite is the world's most widely deployed database engine, embedded in countless applications across all platforms. HarmonyLite extends SQLite's capabilities by:

- Enabling horizontal scaling for read-heavy applications
- Supporting multi-directional writes across all nodes
- Providing eventual consistency with no global locking
- Running as a lightweight sidecar to your existing processes
- Requiring zero modifications to your application code

## Quick Start Guide

1. Download the [latest release](https://github.com/wongfei2009/harmonylite/releases/latest) and extract:

```bash
tar vxzf harmonylite-v*.tar.gz
```

2. Start a demonstration cluster:

```bash
./examples/run-cluster.sh
```

3. Insert data into the first database:

```bash
sqlite3 /tmp/harmonylite-1.db
sqlite> PRAGMA trusted_schema = ON;
sqlite> INSERT INTO Books (title, author, publication_year) VALUES ('Pride and Prejudice', 'Jane Austen', 1813);
```

4. Verify replication by checking the second database:

```bash
sqlite3 /tmp/harmonylite-2.db
sqlite> SELECT * FROM Books;
```

You should see your changes automatically propagated across all nodes in the cluster.

## How HarmonyLite Works

HarmonyLite uses Change Data Capture (CDC) to monitor database changes via SQLite triggers. When a change occurs:

1. The change is captured via database triggers
2. The change is published to NATS JetStream
3. All nodes (including the originating node) apply the changes in a deterministic order
4. Last-writer-wins conflict resolution ensures eventual consistency

### Comparison with Other Solutions

| Feature | HarmonyLite | rqlite | dqlite | LiteFS |
|---------|-------------|--------|--------|--------|
| Architecture | Leaderless | Leader-follower | Leader-follower | Primary-replica |
| Consistency | Eventual | Strong | Strong | Strong |
| Write nodes | All nodes | Leader only | Leader only | Primary only |
| Application changes | None | API changes | API changes | VFS layer |
| Replication level | Logical (row) | Logical (SQL) | Physical | Physical |

Unlike solutions like [rqlite](https://github.com/rqlite/rqlite), [dqlite](https://dqlite.io/), and [LiteFS](https://github.com/superfly/litefs) which use leader-follower architectures requiring all writes to go through a single primary node, HarmonyLite:

- Allows writes on any node
- Provides eventual consistency without locking
- Requires no application code changes
- Functions as a side-car process alongside your existing applications

## FAQ

### How are race conditions handled?

In HarmonyLite, each row is deterministically mapped to a specific JetStream. When multiple nodes attempt to change the same row simultaneously:

1. All nodes compete to publish their change to the same JetStream
2. NATS' [RAFT consensus](https://docs.nats.io/running-a-nats-service/configuration/clustering/jetstream_clustering#raft) determines which change is accepted first
3. Changes are applied on all nodes in the same order
4. Last-writer-wins ensures eventual consistency

Note that there is no serializability guarantee for transactions spanning multiple tables. This design choice avoids global locking and maximizes performance.

### Does capturing changes with triggers impact storage?

Yes, additional storage is temporarily required to store change records. However:

- Change records are typically processed and cleaned up quickly
- Modern storage is inexpensive
- The storage overhead is minimal compared to the benefits of distributed replication

### How do I clean up HarmonyLite database artifacts?

To remove HarmonyLite hooks and log tables:

```bash
harmonylite -config /path/to/config.toml -cleanup
```

### How many shards should I configure?

For most applications, a single shard is sufficient. Additional shards may be beneficial if:

- You have extremely high write throughput
- You're experiencing NATS JetStream bottlenecks
- You need to partition data for specific scalability requirements

The optimal number depends on your specific workload and infrastructure.

### Can I use HarmonyLite in a primary-replica configuration?

Yes. While HarmonyLite is designed for multi-directional replication, you can configure it for a primary-replica setup by adjusting two configuration flags:

1. Set `publish=false` on replica nodes to prevent them from publishing changes
2. Set `replicate=false` on the primary node to prevent it from applying changes from other nodes

This configuration allows writes only on the primary while replicas remain read-only.